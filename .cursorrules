# Project Instructions

Use specification and guidelines as you build the app.

Write the complete code for every step. Do not get lazy.

Your goal is to completely finish whatever I ask for.

You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Radix UI, Tailwind, tRPC, DrizzleORM, and Trigger.dev

## Tech Stack

- Frontend: Next.js, Tailwind, Shadcn, Framer Motion
- Backend: Postgres, Supabase, Drizzle ORM, tRPC, Trigger.dev v3, Cloudflare R2
- Auth: Clerk
- Payments: Stripe
- Analytics: PostHog
- Deployment: Vercel
- Services: Resend (for emails), Sentry, Sanity (CSM)

## Code Style and Structure

- We're using the the T3 Stack
- We're using pnpm
- Write concise, technical TypeScript code with accurate examples.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.
- We're using react query for making mutations. Import the trpc/react api to create new mutations

## Rules

Follow these rules when building the app.

### General Rules

- Use `@` to import anything from the app unless otherwise specified
- Use lowercase with dashes for directories and files (e.g., components/auth-wizard).
- Use kebab case for all files and folders unless otherwise specified
- Don't update shadcn components unless otherwise specified
- Favor named exports for components.

### Type Rules

- If referring to db types, use `@/db/schema` such as `SelectTodo` from `todos-schema.ts`

### Env Rules

- If you update environment variables, update the `.env.example` file
- All environment variables should go in `.env.local`
- Do not expose environment variables to the frontend
- Use `NEXT_PUBLIC_` prefix for environment variables that need to be accessed from the frontend
- You may import environment variables in server actions and components by using `process.env.VARIABLE_NAME`

### TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types.
- Use functional components with TypeScript interfaces.
- When importing types use type in front (e.g. { type Editor })

#### Syntax and Formatting

- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use declarative JSX.

## Frontend Rules

Follow these rules when working on the frontend.

It uses Next.js, Tailwind, Shadcn, and Framer Motion.

#### General Rules

- Use `lucide-react` for icons

#### Components

- Use divs instead of other html tags unless otherwise specified
- Separate the main parts of a component's html with an extra blank line for visual spacing
- Always tag a component with either `use server` or `use client` at the top, including layouts and pages

#### Organization

- All components be named using kebab case like `example-component.tsx` unless otherwise specified
- Put components in `/_components` in the route if one-off components
- Put components in `/components` from the root if shared components

#### Data Fetching

- Fetch data in server components and pass the data down as props to client components.
- Use server actions from `/actions` to mutate data.

##### Server Components

- Implement Suspense for asynchronous data fetching to show loading states while data is being fetched.
- If no asynchronous logic is required for a given server component, you do not need to wrap the component in `<Suspense>`. You can simply return the final UI directly since there is no async boundary needed.
- If asynchronous fetching is required, you can use a `<Suspense>` boundary and a fallback to indicate a loading state while data is loading.
- Server components cannot be imported into client components. If you want to use a server component in a client component, you must pass the as props using the "children" prop

### UI and Styling

- Use Shadcn UI, Radix, and Tailwind for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.

### Performance Optimization

- Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC).
- Wrap client components in Suspense with fallback.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazy loading.

Key Conventions

- Limit 'use client':
  - Favor server components and Next.js SSR.
  - Use only for Web API access in small components.
  - Avoid for data fetching or state management.
- Fetching data from the server:
  - Use import { api } from '@/trpc/server';
- Mutations:
  - Use import { api } from '@/trpc/react';

### Backend Rules

Follow these rules when working on the backend.

It uses Postgres, Supabase, Drizzle ORM, and tRPC.

#### General Rules

- Never generate migrations. You do not have to do anything in the `db/migrations` folder inluding migrations and metadata. Ignore it.

#### Schemas

- When importing schemas, use `@/db/schema`
- Name files like `example-schema.ts`
- All schemas should go in `db/schema`
- Make sure to export the schema in `db/schema/index.ts`
- Always include createdAt and updatedAt columns in all tables
- Make sure to cascade delete when necessary
- Use enums for columns that have a limited set of possible values such as:

```ts
import { pgEnum } from 'drizzle-orm/pg-core';

export const membershipEnum = pgEnum('membership', ['free', 'pro']);

membership: membershipEnum('membership').notNull().default('free');
```

Example of a schema:

`db/schema/todos-schema.ts`

```ts
import { InferInsertModel, InferSelectModel } from 'drizzle-orm';

const usersTable = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  verified: boolean('verified').notNull().default(false),
  jsonb: jsonb('jsonb').$type<string[]>(),
  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
});

type SelectUser = typeof usersTable.$inferSelect;
type InsertUser = typeof usersTable.$inferInsert;

type SelectUser2 = InferSelectModel<typeof usersTable>;
type InsertUser2 = InferInsertModel<typeof usersTable>;
```

And a more complex schema:

```ts
import { pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';

export const chatsTable = pgTable('chats', {
  id: uuid('id').defaultRandom().primaryKey(),
  userId: text('user_id').notNull(),
  name: text('name').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at')
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date()),
});

export type InsertChat = typeof chatsTable.$inferInsert;
export type SelectChat = typeof chatsTable.$inferSelect;
```

```ts
import { pgEnum, pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';

import { chatsTable } from './chats-schema';

export const roleEnum = pgEnum('role', ['assistant', 'user']);

export const messagesTable = pgTable('messages', {
  id: uuid('id').defaultRandom().primaryKey(),
  chatId: uuid('chat_id')
    .references(() => chatsTable.id, { onDelete: 'cascade' })
    .notNull(),
  content: text('content').notNull(),
  role: roleEnum('role').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at')
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date()),
});

export type InsertMessage = typeof messagesTable.$inferInsert;
export type SelectMessage = typeof messagesTable.$inferSelect;
```

### How to write queries

Use the Query API over using general `db.select()` and create soft relations when applicable.

#### Query

```ts
export const getAllCommentsByInsightId = async ({ db, input }: { db: typeof DrizzleClient; input: { id: number } }) => {
  return db.query.comment.findMany({
    where: eq(comment.insightId, input.id),
  });
};
```

#### Insert

```ts
const createCommentSchema = z.object({ insightId: z.number(), content: z.any() });
const updateCommentSchema = z.object({ id: z.number(), content: z.any() });

type CreateComment = z.infer<typeof createCommentSchema>;
type UpdateComment = z.infer<typeof updateCommentSchema>;

export const createComment = async ({
  db,
  input,
  auth,
}: {
  db: typeof PrismaClient;
  input: CreateComment;
  auth: AuthObject;
}) => {
  return db
    .insert(comment)
    .values({
      authorId: auth.userId!,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      content: input.content,
      insightId: input.insightId,
    })
    .returning();
};
```

#### Update

```ts
export const updateCommentById = async ({ db, input }: { db: typeof DrizzleClient; input: UpdateComment }) => {
  return db
    .update(comment)
    .set({
      content: input.content,
    })
    .where(eq(comment.id, input.id));
};
```

#### Delete

```ts
export const deleteCommentById = async ({ db, input }: { db: typeof DrizzleClient; input: { id: number } }) => {
  return db.delete(comment).where(eq(comment.id, input.id));
};
```

### The tRPC rules

Try splitting the code from the actual tRPC router. Create a new service file when needed and import the service file into the router.

### Auth Rules

Follow these rules when working on auth.

It uses Clerk for authentication.

#### General Rules

- Import the auth helper with `import { auth } from "@clerk/nextjs/server"` in server components
- await the auth helper in server actions

### Payments Rules

Follow these rules when working on payments.

It uses Stripe for payments.

### Analytics Rules

Follow these rules when working on analytics.

It uses PostHog for analytics.
